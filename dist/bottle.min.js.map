{
  "version": 3,
  "sources": ["../src/bottle.ts"],
  "sourcesContent": ["import type {\n    AssertValidContainer,\n    BottleLike,\n    Dependencies,\n    MergedContainer,\n    Providers,\n    ServiceName,\n} from './types.ts';\n\n/**\n * Given a providers definition, builds an object that exposes a `container`\n * property where the services may be accessed (instantiated just-in-time).\n *\n * Optionally takes another Bottle instance as a second paramter. In that\n * case the `container` gives access to all the services, its own and those\n * inherited from the other Bottle.\n *\n * @example\n * ```ts\n * class Water {\n *   public origin = 'Antarctica'\n * }\n * class Barley {\n *   constructor(public water: Water) {}\n * }\n *\n * const providers = {\n *   barley: (container: { water: Water }) => new Barley(container.water),\n *   water: () => new Water(),\n * };\n * const bottle = new Bottle(providers);\n * console.log(bottle.container.barley.water.origin);\n * // Antarctica\n * console.log(bottle.container.barley.water === bottle.container.water);\n * // true\n * ```\n */\nexport class Bottle<\n    T extends Providers,\n    U extends BottleLike | undefined = undefined,\n> implements BottleLike {\n    protected _dependents: Map<\n        ServiceName,\n        Set<[ServiceName, BottleLike]>\n    > = new Map<\n        ServiceName,\n        Set<[ServiceName, BottleLike]>\n    >();\n    protected _instances: Map<ServiceName, any> = new Map<ServiceName, any>();\n    protected _tracking: Array<[ServiceName, BottleLike]> = [];\n\n    public container: AssertValidContainer<\n        MergedContainer<T, U>,\n        Dependencies<T>\n    > = new Proxy({} as typeof this.container, {\n        deleteProperty: (_, serviceName: ServiceName) => {\n            this.delete(serviceName);\n            // In any case keep the behaviour of \"delete\" on plain objects (do not throw)\n            return true;\n        },\n        get: (_, serviceName: ServiceName) => {\n            // If the accessed service is NOT my own\n            if (!this._isOwnService(serviceName)) {\n                // Then It must be from an ancestor\n                if (this._ancestor) {\n                    return this._ancestor.container[serviceName];\n                }\n                // Otherwise this is an error\n                throw new Error(`Unknown service \"${String(serviceName)}\"`);\n            }\n            // If the accessed service is my own,\n            // and It has not been instantiated\n            if (!this._instances.has(serviceName)) {\n                // Let's keep track of other accessed services during the instantiation\n                this._track(serviceName);\n                // Proceed to instantiation\n                this._instances.set(\n                    serviceName,\n                    this._providers[serviceName](this.container),\n                );\n                // And stop tracking what has been accessed during instantiation\n                this._stopTrack();\n            }\n            // If there is an on-going instantiation\n            if (this._tracking.length) {\n                // The currently accessed service is a dependency of that on-going\n                // instantiation. Take note that It depends on this one.\n                const currentInstantiation =\n                    this._tracking[this._tracking.length - 1];\n                this._dependents.set(\n                    serviceName,\n                    (this._dependents.get(serviceName) ||\n                        new Set<[ServiceName, Bottle<any, any>]>())\n                        .add(currentInstantiation),\n                );\n            }\n            // Finally return the accessed service instance\n            return this._instances.get(serviceName);\n        },\n        getOwnPropertyDescriptor: (_, _serviceName: ServiceName) => {\n            return { configurable: true, enumerable: true, writable: false };\n        },\n        has: (_, serviceName: ServiceName) => {\n            // Either the accessed service is my own\n            if (this._isOwnService(serviceName)) {\n                return true;\n            }\n            // Or It must be from an ancestor\n            if (this._ancestor) {\n                return serviceName in this._ancestor.container;\n            }\n            // Or It does not exist\n            return false;\n        },\n        ownKeys: (_) => {\n            const keys = [...this._instances.keys()];\n            if (this._ancestor) {\n                keys.push(...Reflect.ownKeys(this._ancestor.container));\n            }\n            return keys;\n        },\n    });\n\n    constructor(\n        protected _providers: T,\n        protected _ancestor?: U,\n    ) {}\n\n    /**\n     * Reset a given provider by removing the existing instance.\n     *\n     * By default will reset any provider that depends on this one.\n     * Pass `false` as the second parameter to limit the reset to\n     * this specific service.\n     *\n     * Dependencies tracking is limited to accesses done during the\n     * factory execution.\n     */\n    public delete(serviceName: ServiceName, deep = true): boolean {\n        // If the deleted service is my own\n        if (this._isOwnService(serviceName)) {\n            // Then I'm the bottle that keeps track of the dependent services.\n            if (deep) {\n                // Let's delete any services that depends on this one.\n                const dependentServices = this._dependents.get(serviceName);\n                if (dependentServices) {\n                    for (\n                        const [dependentServiceName, bottleInstance]\n                            of dependentServices\n                    ) {\n                        bottleInstance.delete(dependentServiceName);\n                    }\n                }\n            }\n            // And finally delete the target service\n            return this._instances.delete(serviceName);\n        }\n        // If the deteled service is not mine, must be from an ancestor\n        if (this._ancestor) {\n            return this._ancestor.delete(serviceName, deep);\n        }\n        // Or otherwise it does not exist\n        return false;\n    }\n\n    protected _isOwnService(serviceName: ServiceName): boolean {\n        return serviceName in this._providers;\n    }\n\n    protected _track(\n        serviceName: ServiceName,\n        bottleInstance: BottleLike = this,\n    ) {\n        this._tracking.push([serviceName, bottleInstance]);\n        if (this._ancestor) {\n            // @ts-ignore: privileged access to private prop\n            this._ancestor._track(serviceName, this);\n        }\n    }\n\n    protected _stopTrack() {\n        this._tracking.pop();\n        if (this._ancestor) {\n            // @ts-ignore: privileged access to private prop\n            this._ancestor._stopTrack();\n        }\n    }\n}\n"],
  "mappings": "AAqCO,aAAM,MAGW,CAmFpB,YACcA,EACAC,EACZ,CAFY,KAAAD,IACA,KAAAC,GACX,CArFOC,EAGN,IAAI,IAIEC,EAAoC,IAAI,IACxCC,EAA8C,CAAC,EAElD,UAGH,IAAI,MAAM,CAAC,EAA4B,CACvC,eAAgB,CAACC,EAAGC,KAChB,KAAK,OAAOA,CAAW,EAEhB,IAEX,IAAK,CAACD,EAAGC,IAA6B,CAElC,GAAI,CAAC,KAAKC,EAAcD,CAAW,EAAG,CAElC,GAAI,KAAKL,EACL,OAAO,KAAKA,EAAU,UAAUK,CAAW,EAG/C,MAAM,IAAI,MAAM,oBAAoB,OAAOA,CAAW,CAAC,GAAG,CAC9D,CAeA,GAZK,KAAKH,EAAW,IAAIG,CAAW,IAEhC,KAAKE,EAAOF,CAAW,EAEvB,KAAKH,EAAW,IACZG,EACA,KAAKN,EAAWM,CAAW,EAAE,KAAK,SAAS,CAC/C,EAEA,KAAKG,EAAW,GAGhB,KAAKL,EAAU,OAAQ,CAGvB,MAAMM,EACF,KAAKN,EAAU,KAAKA,EAAU,OAAS,CAAC,EAC5C,KAAKF,EAAY,IACbI,GACC,KAAKJ,EAAY,IAAII,CAAW,GAC7B,IAAI,KACH,IAAII,CAAoB,CACjC,CACJ,CAEA,OAAO,KAAKP,EAAW,IAAIG,CAAW,CAC1C,EACA,yBAA0B,CAACD,EAAGM,KACnB,CAAE,aAAc,GAAM,WAAY,GAAM,SAAU,EAAM,GAEnE,IAAK,CAACN,EAAGC,IAED,KAAKC,EAAcD,CAAW,EACvB,GAGP,KAAKL,EACEK,KAAe,KAAKL,EAAU,UAGlC,GAEX,QAAUI,GAAM,CACZ,MAAMO,EAAO,CAAC,GAAG,KAAKT,EAAW,KAAK,CAAC,EACvC,OAAI,KAAKF,GACLW,EAAK,KAAK,GAAG,QAAQ,QAAQ,KAAKX,EAAU,SAAS,CAAC,EAEnDW,CACX,CACJ,CAAC,EAiBM,OAAON,EAA0BO,EAAO,GAAe,CAE1D,GAAI,KAAKN,EAAcD,CAAW,EAAG,CAEjC,GAAIO,EAAM,CAEN,MAAMC,EAAoB,KAAKZ,EAAY,IAAII,CAAW,EAC1D,GAAIQ,EACA,SACU,CAACC,EAAsBC,CAAc,IACpCF,EAEPE,EAAe,OAAOD,CAAoB,CAGtD,CAEA,OAAO,KAAKZ,EAAW,OAAOG,CAAW,CAC7C,CAEA,OAAI,KAAKL,EACE,KAAKA,EAAU,OAAOK,EAAaO,CAAI,EAG3C,EACX,CAEUN,EAAcD,EAAmC,CACvD,OAAOA,KAAe,KAAKN,CAC/B,CAEUQ,EACNF,EACAU,EAA6B,KAC/B,CACE,KAAKZ,EAAU,KAAK,CAACE,EAAaU,CAAc,CAAC,EAC7C,KAAKf,GAEL,KAAKA,EAAUO,EAAOF,EAAa,IAAI,CAE/C,CAEUG,GAAa,CACnB,KAAKL,EAAU,IAAI,EACf,KAAKH,GAEL,KAAKA,EAAUQ,EAAW,CAElC,CACJ",
  "names": ["_providers", "_ancestor", "_dependents", "_instances", "_tracking", "_", "serviceName", "_isOwnService", "_track", "_stopTrack", "currentInstantiation", "_serviceName", "keys", "deep", "dependentServices", "dependentServiceName", "bottleInstance"]
}
